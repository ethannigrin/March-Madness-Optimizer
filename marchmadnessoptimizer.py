# -*- coding: utf-8 -*-
"""MarchMadnessOptimizer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s33beb3Njod6V7gbg1jynYSZsVOUPUVn
"""

import numpy as np
from math import erf, sqrt
import math
import pandas as pd

"""DATA"""

teams = np.array([
    # South Region
    "Auburn", "Alabama State",
    "Louisville", "Creighton",
    "Michigan", "UC San Diego",
    "Texas A&M", "Yale",
    "Mississippi", "North Carolina",
    "Iowa State", "Lipscomb",
    "Marquette", "New Mexico",
    "Michigan State", "Bryant",
    # West Region
    "Florida", "Norfolk State",
    "Connecticut", "Oklahoma",
    "Memphis", "Colorado State",
    "Maryland", "Grand Canyon",
    "Missouri", "Drake",
    "Texas Tech", "UNC Wilmington",
    "Kansas", "Arkansas",
    "St. John's", "Omaha",
    # East Region
    "Duke", "American",
    "Mississippi State", "Baylor",
    "Oregon", "Liberty",
    "Arizona", "Akron",
    "BYU", "VCU",
    "Wisconsin", "Montana",
    "Saint Mary's", "Vanderbilt",
    "Alabama", "Robert Morris",
    # Midwest Region
    "Houston", "SIU Edwardsville",
    "Gonzaga", "Georgia",
    "Clemson", "McNeese",
    "Purdue", "High Point",
    "Illinois", "Xavier/Texas",
    "Kentucky", "Troy",
    "UCLA", "Utah State",
    "Tennessee", "Wofford"
])

team_tempo = np.array([
    67.6, 67.7,
    68.8, 67.0,
    69.4, 65.7,
    66.1, 67.2,
    68.0, 70.4,
    68.6, 65.9,
    67.6, 72.7,
    67.7, 72.5,

    69.6, 66.3,
    63.7, 68.5,
    70.8, 66.0,
    69.8, 71.4,
    68.2, 58.8,
    65.4, 65.3,
    68.4, 69.3,
    70.1, 67.7,

    65.7, 63.5,
    68.1, 64.5,
    67.6, 65.3,
    69.9, 71.4,
    67.2, 66.1,
    67.6, 67.0,
    61.7, 69.5,
    74.9, 67.8,

    61.4, 65.8,
    70.2, 66.4,
    64.3, 65.4,
    65.0, 66.4,
    71.3, 68.0,
    70.9, 66.3,
    64.9, 67.5,
    63.6, 64.0])







team_ratings = np.array([
    # South Region
    35.05, -9.24,
    22.64, 18.70,
    22.28, 18.77,
    24.08, 11.05,
    22.09, 19.55,
    26.99, 9.49,
    21.58, 17.32,
    27.57, 1.18,
    # West Region
    36.16, -1.53,
    19.34, 18.36,
    15.35, 17.29,
    26.35, 7.22,
    24.42, 14.14,
    28.05, 5.14,
    23.26, 17.71,
    26.38, 0.51,
    # East Region
    38.16, -5.98,
    20.10, 21.15,
    20.15, 13.53,
    25.72, 6.58,
    22.39, 20.61,
    25.97, 0.38,
    23.09, 16.16,
    29.93, 2.09,
    # Midwest Region
    35.44, -4.32,
    27.29, 19.39,
    23.93, 13.69,
    23.84, 9.30,
    23.56, 17.13,
    24.26, 6.88,
    21.76, 15.22,
    31.15, 4.16
])






public_odds = np.array([
    1, 0.89, 0.72, 0.54, 0.32, 0.20, # Auburn
    0, 0, 0, 0, 0, 0, # Alabama State
    0.57, 0.07, 0.03, 0.01, 0, 0, #LVille
    0.43, 0.04, 0.02, 0.01, 0, 0, # The Once Beautiful Team
    0.79, 0.50, 0.13, 0.05, 0.02, 0.01, # Michigan
    0.21, 0.09, 0.01, 0, 0, 0, #UC San Diego
    0.75, 0.36, 0.08, 0.04, 0.01, 0, # Texas A&M
    0.25, 0.05, 0, 0, 0, 0, # Yale
    0.70, 0.27, 0.10, 0.02, 0.01, 0, # Ole Miss
    0.30, 0.12, 0.03, 0, 0, 0, # UNC
    0.92, 0.60, 0.18, 0.06, 0.03, 0.01, # Iowa St
    0.08, 0.01, 0, 0, 0, 0, # Lipscomb
    0.65, 0.14, 0.06, 0.01, 0.01, 0, # Marquette
    0.35, 0.07, 0.02, 0, 0, 0, # UNM
    0.97, 0.78, 0.59, 0.24, 0.08, 0.04, # Michigan State
    0.03, 0.01, 0, 0, 0, 0, # Bryant

    1, 0.89, 0.78, 0.60, 0.34, 0.20, # Florida
    0, 0, 0, 0, 0, 0, # Alabama St
    0.70, 0.08, 0.05, 0.02, 0.01, 0, # Uconn
    0.30, 0.02, 0.01, 0, 0, 0, # Oklahoma
    0.70, 0.31, 0.05, 0.02, 0.01, 0, # Memphis
    0.20, 0.08, 0, 0, 0, 0, # Colorado St
    0.87, 0.58, 0.10, 0.05, 0.02, 0.01, # Maryland
    0.13, 0.03, 0, 0, 0, 0, # Grand Canyon
    0.62, 0.21, 0.08, 0.02, 0.01, 0, # Missouri
    0.38, 0.12, 0.03, 0.01, 0, 0, # Drake
    0.93, 0.65, 0.26, 0.08, 0.03, 0.01, # Texas Tech
    0.07, 0.01, 0, 0, 0, 0, # UNW
    0.63, 0.18, 0.08, 0.02, 0.01, 0, # Kansas
    0.37, 0.09, 0.03, 0, 0, 0, # Arkansas
    0.96, 0.72, 0.52, 0.18, 0.09, 0.04, # St John's
    0.04, 0.01, 0, 0, 0, 0, # Omaha

    1, 0.93, 0.81, 0.64, 0.45, 0.22, # Duke
    0, 0, 0, 0, 0, 0, # American
    0.41, 0.03, 0.01, 0, 0, 0, # Miss State
    0.59, 0.03, 0.01, 0.01, 0, 0, # Baylor
    0.82, 0.33, 0.05, 0.02, 0.01, 0, # Oregon
    0.18, 0.06, 0, 0, 0, 0, # Liberty
    0.87, 0.58, 0.10, 0.05, 0.02, 0.01, # Arizona
    0.13, 0.03, 0, 0, 0, 0, # Akron
    0.66, 0.26, 0.09, 0.02, 0.01, 0, # BYU
    0.34, 0.12, 0.04, 0, 0, 0, # VCU
    0.94, 0.61, 0.24, 0.07, 0.03, 0.01, # Wisconsin
    0.06, 0.01, 0, 0, 0, 0, # Montana
    0.62, 0.11, 0.04, 0.01, 0, 0, # Saint Mary's
    0.38, 0.08, 0.03, 0, 0, 0, # Vanderbilt
    0.98, 0.80, 0.56, 0.18, 0.08, 0.03, # Alabama
    0.02, 0.01, 0, 0, 0, 0, # Robert Morris

    1, 0.86, 0.72, 0.52, 0.22, 0.10, # Houston
    0, 0, 0, 0, 0, 0, # SIU Edwardsville
    0.71, 0.11, 0.06, 0.03, 0.01, 0, # Gonzaga
    0.29, 0.03, 0.02, 0.01, 0, 0, # Georgia
    0.82, 0.49, 0.10, 0.04, 0.01, 0, # Clemson
    0.18, 0.07, 0.01, 0, 0, 0, # McNeese
    0.85, 0.41, 0.09, 0.04, 0.01, 0.01, # Purdue
    0.15, 0.03, 0, 0, 0, 0, # Maxwell Rattet
    0.79, 0.31, 0.08, 0.02, 0.01, 0, # Illinois
    0.21, 0.07, 0.02, 0, 0, 0, # Xavier/Texas
    0.93, 0.61, 0.21, 0.09, 0.03, 0.01, # Kentucky
    0.07, 0.01, 0, 0, 0, 0, # Troy
    0.68, 0.12, 0.05, 0.01, 0, 0, # UCLA
    0.32, 0.06, 0.02, 0, 0, 0, # Utah St
    0.98, 0.81, 0.62, 0.23, 0.09, 0.03, # Tennessee
    0.02, 0.01, 0, 0, 0, 0, # Wofford
]).reshape(64,6)

# Define the shape of the matrix
rows, cols = 64, 6

# Generate the matrix
matrix = np.array([[1 / 2**(i+1) for i in range(cols)] for _ in range(rows)])

# Display the result
public_odds = 0.064 * matrix + (1-.064) * public_odds
print(public_odds.shape)
print(public_odds[0,:])

"""To Name Bracket"""

def to_name_bracket(bracket, teams):
    return teams[bracket]

"""Simulating Tournaments"""

def matchup_probability(team1_rating, team2_rating, team1_tempo, team2_tempo):
  expected_margin = (team1_rating - team2_rating) * (team1_tempo + team2_tempo) / 200.0
  sigma = 11.0
  return 0.5 * (1 + erf(expected_margin / (sigma * sqrt(2))))

def simulate_tournaments(team_ratings, team_tempo, N):
    """
    Simulates N tournaments using the provided team ratings.

    Parameters
    ----------
    teams : np.array
        Array of team names (or any unique identifiers).
    team_ratings : np.array
        Array of length 64 with each team's rating.
    N : int
        Number of tournaments to simulate.

    Returns
    -------
    tournaments : np.array of shape (N, 63)
        Each row is a tournament bracket of length 63, where each element
        is the index (in 'teams') of the winner at each bracket node.
    """
    # Create an empty NumPy array for N tournaments, each with 63 nodes.
    tournaments = np.empty((N, 63), dtype=int)

    # Simulate each tournament independently
    for t in range(N):
        # Round of 64 -> Round of 32 (nodes 62 down to 31)
        for i in range(62, 30, -1):
            team_1_idx = (i - 31) * 2
            team_2_idx = team_1_idx + 1

            # Identify the two teams' ratings
            team_1_rating = team_ratings[team_1_idx]
            team_2_rating = team_ratings[team_2_idx]
            team_1_tempo = team_tempo[team_1_idx]
            team_2_tempo = team_tempo[team_2_idx]

            # Calculate probability of team 1 winning
            probability_of_team_1_winning = matchup_probability(team_1_rating, team_2_rating, team_1_tempo, team_2_tempo)

            # Sample random number to see which team advances
            if np.random.random() < probability_of_team_1_winning:
                tournaments[t, i] = team_1_idx
            else:
                tournaments[t, i] = team_2_idx

        # Round of 32 -> Championship (nodes 30 down to 0)
        for i in range(30, -1, -1):
            # Identify the two teams' ratings based on winners at child nodes
            team_1_idx = tournaments[t, 2*i + 1]
            team_2_idx = tournaments[t, 2*i + 2]

            team_1_rating = team_ratings[team_1_idx]
            team_2_rating = team_ratings[team_2_idx]
            team_1_tempo = team_tempo[team_1_idx]
            team_2_tempo = team_tempo[team_2_idx]

            # Probability of team 1 winning
            probability_of_team_1_winning = matchup_probability(team_1_rating, team_2_rating, team_1_tempo, team_2_tempo)

            # Determine winner
            if np.random.random() < probability_of_team_1_winning:
                tournaments[t, i] = team_1_idx
            else:
                tournaments[t, i] = team_2_idx

    return tournaments

def print_tournament_tree(winners):
    """
    Prints the winner names in levels: 1, 2, 4, 8, 16, 32.
    """
    levels = np.array([1, 2, 4, 8, 16, 32])
    start = 0
    for level in levels:
        print(", ".join(winners[start : start + level]))
        start += level

# Example usage:
brackets = simulate_tournaments(team_ratings, team_tempo, 1000)
winners = np.zeros(64)
for i in range(brackets.shape[0]):
  winners[brackets[i,0]] += 1
winners = winners / brackets.shape[0]
for i in range(63):
  print(f"{teams[i]}: {winners[i]}")

"""Generate brackets randomly from public odds"""

def generate_public_brackets(public_odds, N):
  brackets = np.empty((N, 63), dtype=int)
  lr_indexer = [None] * 63   # Will store tuples (left_bound, right_bound)
  mid_indexer = [None] * 63  # Will store a single float midpoint for each node

  queue = [(0, 0, 63)]

  while queue:
      idx, left_bound, right_bound = queue.pop(0)
      mid = (left_bound + right_bound) / 2.0

      lr_indexer[idx] = (int(left_bound), int(right_bound))

      mid_indexer[idx] = mid

      left_child = 2 * idx + 1
      right_child = 2 * idx + 2

      if left_child < 63:
          queue.append((left_child, left_bound, np.floor(mid)))

      if right_child < 63:
          queue.append((right_child, np.ceil(mid), right_bound))

  for b in range(N):
    match_visited = np.zeros(63)
    for idx in range(63):
      if match_visited[idx] == 0:
        round_idx = 5 - int(np.floor(np.log2(idx + 1)))
        candidate_odds = public_odds[lr_indexer[idx][0]:lr_indexer[idx][1], round_idx]
        candidate_odds = candidate_odds / np.sum(candidate_odds)
        selected_team = np.random.choice(len(candidate_odds), p=candidate_odds) + lr_indexer[idx][0]
        node = idx
        while node < 63:
          brackets[b, node] = selected_team
          match_visited[node] = 1
          if selected_team < mid_indexer[node]:
            node = 2 * node + 1  # Left child
          else:
            node = 2 * node + 2  # Right child
  return brackets




# Example usage:
brackets = generate_public_brackets(public_odds, 1000)
winners = np.zeros(brackets.shape[1])
for i in range(brackets.shape[0]):
  winners[brackets[i,0]] += 1
winners = winners / brackets.shape[0]
for i in range(63):
  print(f"{teams[i]}: {winners[i]}")

"""Bracket Scorer"""

round_picks = [32, 16, 8, 4, 2, 1]
round_scores = [1, 2, 4, 8, 16, 32]

scoring_vector = np.repeat(round_scores, round_picks)
assert len(scoring_vector) == 63

def score_brackets(brackets, tournaments, scoring_vector):
    num_brackets, _ = brackets.shape
    num_tournaments, _ = tournaments.shape

    scores = np.zeros((num_brackets, num_tournaments), dtype=int)

    for k in range(63):
        matches_k = (brackets[:, k][:, None] == tournaments[:, k][None, :])  # broadcasting
        scores += matches_k.astype(int) * scoring_vector[k]

    return scores

tournaments = simulate_tournaments(team_ratings, team_tempo, 3)
print(score_brackets(tournaments, tournaments, scoring_vector))

"""Hyper Parameters"""

num_brackets = 2
pool_size = 118
winning_splits = [1.0]

round_picks = [32, 16, 8, 4, 2, 1]
round_scores = [1, 2, 4, 8, 16, 32]
scoring_vector = np.repeat(round_scores, round_picks)
print(scoring_vector)

"""Expected Earnings from bracket"""

def expected_earnings(brackets, pool_size, winning_splits, scoring_vector, tournaments, top_scores, ind_idx = None):
   revenue = -brackets.shape[0]
   my_scores = score_brackets(brackets, tournaments, scoring_vector)
   combined_scores = np.vstack((my_scores, top_scores))
   placement = np.zeros_like(combined_scores, dtype=float)
   if ind_idx is None:
     placement[:num_brackets, :] = 1

   else:
     placement[ind_idx, :] = 1
   num_rows, num_cols = combined_scores.shape
   for col in range(num_cols):
       order = np.argsort(combined_scores[:, col])[::-1]
       placement[:, col] = placement[order, col]

   row_means = placement.mean(axis=1)

   top_means = row_means[:len(winning_splits)]
   return revenue + np.dot(top_means, winning_splits) * (brackets.shape[0] + pool_size)

"""Sample top scores"""

def sample_top_scores(scores, pool_size, winning_splits):
    N, M = scores.shape
    k = len(winning_splits)

    top_scores = np.empty((k, M), dtype=float)

    row_idx = 0
    for col in range(M):
      random_indices = np.random.choice(N, size=pool_size, replace=False)

      pool_values = scores[random_indices, col]

      top_k_indices = np.argsort(pool_values)[-k:]
      top_k_values = pool_values[top_k_indices]

      top_k_values_sorted = np.sort(top_k_values)[::-1]

      top_scores[:, col] = top_k_values_sorted

    return top_scores

"""Optimizer"""

def bracket_optimizer(my_brackets, pool_size, winning_splits, scoring_vector, tournaments, top_scores, search_space = [2, 4, 6, 8, 16, 20]):

  lr_indexer = [None] * 63
  mid_indexer = [None] * 63

  queue = [(0, 0, 63)]

  while queue:
      idx, left_bound, right_bound = queue.pop(0)
      mid = (left_bound + right_bound) / 2.0

      lr_indexer[idx] = (int(left_bound), int(right_bound))

      mid_indexer[idx] = mid

      left_child = 2 * idx + 1
      right_child = 2 * idx + 2

      if left_child < 63:
          queue.append((left_child, left_bound, np.floor(mid)))

      if right_child < 63:
          queue.append((right_child, np.ceil(mid), right_bound))

  match_candidates = [None] * 63
  for i in range(63):
    round_idx = 5 - int(math.floor(math.log2(i + 1)))
    k = search_space[round_idx]
    start_idx = lr_indexer[i][0]
    end_idx   = lr_indexer[i][1]
    ratings_slice = team_ratings[start_idx:end_idx+1]
    global_indices = np.arange(start_idx, end_idx + 1)
    sorted_local_indices = np.argsort(ratings_slice)[::-1][:k]
    topk_global_indices  = global_indices[sorted_local_indices]
    match_candidates[i] = topk_global_indices

  match_visited = np.zeros_like(my_brackets, dtype=int)
  num_brackets, _ = my_brackets.shape
  for i in range(63):
    for j in range(num_brackets):
      if match_visited[j, i] == 0:

        best_candidate = None
        best_earnings = -1000000

        for candidate in match_candidates[i]:

          my_test_brackets = my_brackets.copy()
          node = i
          while node < 63:
            my_test_brackets[j, node] = candidate
            if candidate < mid_indexer[node]:
              node = 2 * node + 1
            else:
              node = 2 * node + 2

          candidate_earnings = expected_earnings(my_test_brackets, pool_size, winning_splits, scoring_vector, tournaments, top_scores, ind_idx = None)

          if candidate_earnings > best_earnings:
              best_earnings = candidate_earnings
              best_candidate = candidate

        node = i
        while node < 63:
          my_brackets[j, node] = best_candidate
          match_visited[j, node] = 1
          if best_candidate < mid_indexer[node]:
            node = 2 * node + 1  # Left child
          else:
            node = 2 * node + 2  # Right child

  return my_brackets

"""Make Initial Guess for Bracket"""

brackets = generate_public_brackets(public_odds, pool_size)
tournaments = simulate_tournaments(team_ratings, team_tempo, 10000)
scores = score_brackets(brackets, tournaments, scoring_vector)

winners = np.zeros(brackets.shape[1])
for i in range(brackets.shape[0]):
  winners[brackets[i,0]] += 1
for i in range(63):
  print(f"{teams[i]}: {winners[i]}")

total_payouts = np.zeros(brackets.shape[0])
num_tournaments = scores.shape[1]
for col in range(num_tournaments):
    sorted_indices = np.argsort(scores[:, col])[::-1]
    for i in range(len(winning_splits)):
      total_payouts[sorted_indices[i]] += winning_splits[i]

top_indices = np.argsort(total_payouts)[-num_brackets:]
my_brackets = brackets[top_indices]

"""Data"""

brackets_op = generate_public_brackets(public_odds, 10000)
tournaments_op = simulate_tournaments(team_ratings, team_tempo, 10000)
scores_op = score_brackets(brackets_op, tournaments_op, scoring_vector)
top_scores_op = sample_top_scores(scores_op, pool_size, winning_splits)

"""Optimizer Main"""

for i in range(num_brackets):
    print(f"\nBracket copy {i+1}:")
    print_tournament_tree(to_name_bracket(my_brackets[i, :], teams))
print(f"Expected Revenue: {expected_earnings(my_brackets, pool_size, winning_splits, scoring_vector, tournaments_op, top_scores_op)}")

run_throughs = 20
for i in range(run_throughs):
  print(f"\nRun #{i+1}")
  my_brackets = bracket_optimizer(my_brackets, pool_size, winning_splits, scoring_vector, tournaments_op, top_scores_op)
  for j in range(num_brackets):
    print(f"\nBracket copy {j+1}:")
    print_tournament_tree(to_name_bracket(my_brackets[j, :], teams))
  print(f"Expected Revenue: {expected_earnings(my_brackets, pool_size, winning_splits, scoring_vector, tournaments_op, top_scores_op)}")